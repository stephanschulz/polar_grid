<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Half Cylinder Room Simulator</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #1e3c72 0%, #2a5298 100%);
            color: #fff;
            min-height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
            padding: 20px;
        }

        .container {
            background: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(10px);
            border-radius: 20px;
            padding: 20px;
            box-shadow: 0 8px 32px 0 rgba(0, 0, 0, 0.37);
            max-width: 900px;
            width: 100%;
        }

        h1 {
            text-align: center;
            margin-bottom: 20px;
            font-size: 2em;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.3);
        }

        .canvas-wrapper {
            background: #fff;
            border-radius: 10px;
            padding: 15px;
            margin-bottom: 20px;
            box-shadow: 0 4px 16px rgba(0, 0, 0, 0.2);
        }

        canvas {
            display: block;
            width: 100%;
            height: auto;
            border-radius: 5px;
        }

        .controls {
            display: grid;
            gap: 12px;
        }

        .control-group {
            background: rgba(255, 255, 255, 0.15);
            padding: 12px 15px;
            border-radius: 10px;
            backdrop-filter: blur(5px);
        }

        .control-group label {
            display: block;
            font-weight: 600;
            margin-bottom: 6px;
            font-size: 1em;
        }

        .control-row {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        input[type="range"] {
            flex: 1;
            height: 8px;
            border-radius: 5px;
            background: rgba(255, 255, 255, 0.3);
            outline: none;
            -webkit-appearance: none;
        }

        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: #4CAF50;
            cursor: pointer;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.3);
            transition: all 0.2s;
        }

        input[type="range"]::-webkit-slider-thumb:hover {
            background: #45a049;
            transform: scale(1.1);
        }

        input[type="range"]::-moz-range-thumb {
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: #4CAF50;
            cursor: pointer;
            border: none;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.3);
            transition: all 0.2s;
        }

        input[type="range"]::-moz-range-thumb:hover {
            background: #45a049;
            transform: scale(1.1);
        }

        .value-display {
            min-width: 70px;
            text-align: right;
            font-size: 0.95em;
            font-weight: 600;
            background: rgba(0, 0, 0, 0.2);
            padding: 4px 10px;
            border-radius: 5px;
        }

        .info {
            text-align: center;
            margin-top: 12px;
            font-size: 0.9em;
            opacity: 0.8;
        }

        .menu-bar {
            display: flex;
            gap: 10px;
            margin-bottom: 20px;
            background: rgba(255, 255, 255, 0.1);
            padding: 10px;
            border-radius: 10px;
        }

        .menu-tab {
            flex: 1;
            padding: 10px 20px;
            background: rgba(255, 255, 255, 0.1);
            border: 2px solid transparent;
            border-radius: 8px;
            cursor: pointer;
            text-align: center;
            font-weight: 600;
            transition: all 0.3s;
        }

        .menu-tab:hover {
            background: rgba(255, 255, 255, 0.2);
        }

        .menu-tab.active {
            background: rgba(76, 175, 80, 0.3);
            border-color: #4CAF50;
        }

        .option-content {
            display: none;
        }

        .option-content.active {
            display: block;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>Half Cylinder Room Simulator</h1>
        
        <div class="menu-bar">
            <div class="menu-tab active" onclick="switchOption(1)">Option 1: Dots on Polar Lines</div>
            <div class="menu-tab" onclick="switchOption(2)">Option 2: Curved Lines</div>
            <div class="menu-tab" onclick="switchOption(3)">Option 3: Grid Projection</div>
        </div>

        <div class="canvas-wrapper">
            <canvas id="canvas" width="800" height="600"></canvas>
        </div>

        <!-- Option 1 Controls -->
        <div id="option1" class="option-content active">
        <div class="controls">
            <div class="control-group">
                <label>Outer Diameter</label>
                <div class="control-row">
                    <input type="range" id="outerDiameter" min="100" max="500" value="500" step="10">
                    <span class="value-display"><span id="outerValue">500</span> px</span>
                </div>
            </div>

            <div class="control-group">
                <label>Inner Diameter</label>
                <div class="control-row">
                    <input type="range" id="innerDiameter" min="50" max="450" value="150" step="10">
                    <span class="value-display"><span id="innerValue">150</span> px</span>
                </div>
            </div>

            <div class="control-group">
                <label>Circle Resolution (Segments)</label>
                <div class="control-row">
                    <input type="range" id="resolution" min="3" max="100" value="11" step="1">
                    <span class="value-display"><span id="resolutionValue">11</span></span>
                </div>
            </div>

            <div class="control-group">
                <label>Polar Lines per Segment</label>
                <div class="control-row">
                    <input type="range" id="polarLines" min="0" max="10" value="3" step="1">
                    <span class="value-display"><span id="polarLinesValue">3</span></span>
                </div>
            </div>

            <div class="control-group">
                <label>Dots per Polar Line</label>
                <div class="control-row">
                    <input type="range" id="dotsPerLine" min="0" max="20" value="5" step="1">
                    <span class="value-display"><span id="dotsPerLineValue">5</span></span>
                </div>
            </div>

            <div class="control-group">
                <label>Dot Spacing Bias (Inner â†” Outer)</label>
                <div class="control-row">
                    <input type="range" id="spacingBias" min="-2" max="2" value="0" step="0.1">
                    <span class="value-display"><span id="spacingBiasValue">0.0</span></span>
                </div>
            </div>
        </div>
        <div class="info">
            Adjust the sliders to control the half cylinder's dimensions and tessellation
        </div>
        </div>
        <!-- End Option 1 -->

        <!-- Option 2 Controls -->
        <div id="option2" class="option-content">
        <div class="controls">
            <div class="control-group">
                <label>Outer Diameter</label>
                <div class="control-row">
                    <input type="range" id="outerDiameter2" min="100" max="500" value="500" step="10">
                    <span class="value-display"><span id="outerValue2">500</span> px</span>
                </div>
            </div>

            <div class="control-group">
                <label>Inner Diameter</label>
                <div class="control-row">
                    <input type="range" id="innerDiameter2" min="50" max="450" value="150" step="10">
                    <span class="value-display"><span id="innerValue2">150</span> px</span>
                </div>
            </div>

            <div class="control-group">
                <label>Circle Resolution (Segments)</label>
                <div class="control-row">
                    <input type="range" id="resolution2" min="3" max="100" value="11" step="1">
                    <span class="value-display"><span id="resolutionValue2">11</span></span>
                </div>
            </div>

            <div class="control-group">
                <label>Polar Lines per Segment</label>
                <div class="control-row">
                    <input type="range" id="polarLines2" min="0" max="10" value="3" step="1">
                    <span class="value-display"><span id="polarLinesValue2">3</span></span>
                </div>
            </div>

            <div class="control-group">
                <label>Curved Lines Count</label>
                <div class="control-row">
                    <input type="range" id="curvedLines" min="0" max="20" value="5" step="1">
                    <span class="value-display"><span id="curvedLinesValue">5</span></span>
                </div>
            </div>

            <div class="control-group">
                <label>Curve Spacing Bias</label>
                <div class="control-row">
                    <input type="range" id="curveSpacingBias" min="-2" max="2" value="0" step="0.1">
                    <span class="value-display"><span id="curveSpacingBiasValue">0.0</span></span>
                </div>
            </div>

            <div class="control-group">
                <label>Dot Spacing on Curves</label>
                <div class="control-row">
                    <input type="range" id="dotSpacingOnCurves" min="10" max="100" value="30" step="5">
                    <span class="value-display"><span id="dotSpacingOnCurvesValue">30</span> px</span>
                </div>
            </div>
        </div>
        <div class="info">
            Curved lines connect polar lines at evenly spaced radial distances
        </div>
        </div>
        <!-- End Option 2 -->

        <!-- Option 3 Controls -->
        <div id="option3" class="option-content">
        <div class="controls">
            <div class="control-group">
                <label>Outer Diameter</label>
                <div class="control-row">
                    <input type="range" id="outerDiameter3" min="100" max="500" value="500" step="10">
                    <span class="value-display"><span id="outerValue3">500</span> px</span>
                </div>
            </div>

            <div class="control-group">
                <label>Inner Diameter</label>
                <div class="control-row">
                    <input type="range" id="innerDiameter3" min="50" max="450" value="150" step="10">
                    <span class="value-display"><span id="innerValue3">150</span> px</span>
                </div>
            </div>

            <div class="control-group">
                <label>Circle Resolution (Segments)</label>
                <div class="control-row">
                    <input type="range" id="resolution3" min="3" max="100" value="11" step="1">
                    <span class="value-display"><span id="resolutionValue3">11</span></span>
                </div>
            </div>

            <div class="control-group">
                <label>Polar Lines per Segment</label>
                <div class="control-row">
                    <input type="range" id="polarLines3" min="0" max="10" value="3" step="1">
                    <span class="value-display"><span id="polarLinesValue3">3</span></span>
                </div>
            </div>

            <div class="control-group">
                <label>Grid Square Size</label>
                <div class="control-row">
                    <input type="range" id="gridSquareSize" min="10" max="100" value="30" step="5">
                    <span class="value-display"><span id="gridSquareSizeValue">30</span> px</span>
                </div>
            </div>
        </div>
        <div class="info">
            Regular grid projected onto the polar coordinate system
        </div>
        </div>
        <!-- End Option 3 -->

    </div>

    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');

        // Current option
        let currentOption = 1;

        // Option switching
        function switchOption(option) {
            currentOption = option;
            
            // Update menu tabs
            document.querySelectorAll('.menu-tab').forEach((tab, index) => {
                tab.classList.toggle('active', index + 1 === option);
            });
            
            // Update content visibility
            document.querySelectorAll('.option-content').forEach((content, index) => {
                content.classList.toggle('active', index + 1 === option);
            });
            
            draw();
        }

        // Option 1 Control elements
        const outerDiameterSlider = document.getElementById('outerDiameter');
        const innerDiameterSlider = document.getElementById('innerDiameter');
        const resolutionSlider = document.getElementById('resolution');
        const polarLinesSlider = document.getElementById('polarLines');
        const dotsPerLineSlider = document.getElementById('dotsPerLine');
        const spacingBiasSlider = document.getElementById('spacingBias');

        const outerValue = document.getElementById('outerValue');
        const innerValue = document.getElementById('innerValue');
        const resolutionValue = document.getElementById('resolutionValue');
        const polarLinesValue = document.getElementById('polarLinesValue');
        const dotsPerLineValue = document.getElementById('dotsPerLineValue');
        const spacingBiasValue = document.getElementById('spacingBiasValue');

        // Option 1 State
        let outerDiameter = parseInt(outerDiameterSlider.value);
        let innerDiameter = parseInt(innerDiameterSlider.value);
        let resolution = parseInt(resolutionSlider.value);
        let polarLinesPerSegment = parseInt(polarLinesSlider.value);
        let dotsPerLine = parseInt(dotsPerLineSlider.value);
        let spacingBias = parseFloat(spacingBiasSlider.value);

        // Option 2 Control elements
        const outerDiameterSlider2 = document.getElementById('outerDiameter2');
        const innerDiameterSlider2 = document.getElementById('innerDiameter2');
        const resolutionSlider2 = document.getElementById('resolution2');
        const polarLinesSlider2 = document.getElementById('polarLines2');
        const curvedLinesSlider = document.getElementById('curvedLines');
        const curveSpacingBiasSlider = document.getElementById('curveSpacingBias');
        const dotSpacingOnCurvesSlider = document.getElementById('dotSpacingOnCurves');

        const outerValue2 = document.getElementById('outerValue2');
        const innerValue2 = document.getElementById('innerValue2');
        const resolutionValue2 = document.getElementById('resolutionValue2');
        const polarLinesValue2 = document.getElementById('polarLinesValue2');
        const curvedLinesValue = document.getElementById('curvedLinesValue');
        const curveSpacingBiasValue = document.getElementById('curveSpacingBiasValue');
        const dotSpacingOnCurvesValue = document.getElementById('dotSpacingOnCurvesValue');

        // Option 2 State
        let outerDiameter2 = parseInt(outerDiameterSlider2.value);
        let innerDiameter2 = parseInt(innerDiameterSlider2.value);
        let resolution2 = parseInt(resolutionSlider2.value);
        let polarLinesPerSegment2 = parseInt(polarLinesSlider2.value);
        let curvedLinesCount = parseInt(curvedLinesSlider.value);
        let curveSpacingBias = parseFloat(curveSpacingBiasSlider.value);
        let dotSpacingOnCurves = parseInt(dotSpacingOnCurvesSlider.value);

        // Option 3 Control elements
        const outerDiameterSlider3 = document.getElementById('outerDiameter3');
        const innerDiameterSlider3 = document.getElementById('innerDiameter3');
        const resolutionSlider3 = document.getElementById('resolution3');
        const polarLinesSlider3 = document.getElementById('polarLines3');
        const gridSquareSizeSlider = document.getElementById('gridSquareSize');

        const outerValue3 = document.getElementById('outerValue3');
        const innerValue3 = document.getElementById('innerValue3');
        const resolutionValue3 = document.getElementById('resolutionValue3');
        const polarLinesValue3 = document.getElementById('polarLinesValue3');
        const gridSquareSizeValue = document.getElementById('gridSquareSizeValue');

        // Option 3 State
        let outerDiameter3 = parseInt(outerDiameterSlider3.value);
        let innerDiameter3 = parseInt(innerDiameterSlider3.value);
        let resolution3 = parseInt(resolutionSlider3.value);
        let polarLinesPerSegment3 = parseInt(polarLinesSlider3.value);
        let gridSquareSize = parseInt(gridSquareSizeSlider.value);

        // Event listeners
        outerDiameterSlider.addEventListener('input', (e) => {
            outerDiameter = parseInt(e.target.value);
            outerValue.textContent = outerDiameter;
            
            // Ensure inner is smaller than outer
            if (innerDiameter >= outerDiameter) {
                innerDiameter = outerDiameter - 50;
                innerDiameterSlider.value = innerDiameter;
                innerValue.textContent = innerDiameter;
            }
            innerDiameterSlider.max = outerDiameter - 50;
            
            draw();
        });

        innerDiameterSlider.addEventListener('input', (e) => {
            innerDiameter = parseInt(e.target.value);
            innerValue.textContent = innerDiameter;
            draw();
        });

        resolutionSlider.addEventListener('input', (e) => {
            resolution = parseInt(e.target.value);
            resolutionValue.textContent = resolution;
            draw();
        });

        polarLinesSlider.addEventListener('input', (e) => {
            polarLinesPerSegment = parseInt(e.target.value);
            polarLinesValue.textContent = polarLinesPerSegment;
            draw();
        });

        dotsPerLineSlider.addEventListener('input', (e) => {
            dotsPerLine = parseInt(e.target.value);
            dotsPerLineValue.textContent = dotsPerLine;
            draw();
        });

        spacingBiasSlider.addEventListener('input', (e) => {
            spacingBias = parseFloat(e.target.value);
            spacingBiasValue.textContent = spacingBias.toFixed(1);
            draw();
        });

        // Option 2 Event listeners
        outerDiameterSlider2.addEventListener('input', (e) => {
            outerDiameter2 = parseInt(e.target.value);
            outerValue2.textContent = outerDiameter2;
            
            if (innerDiameter2 >= outerDiameter2) {
                innerDiameter2 = outerDiameter2 - 50;
                innerDiameterSlider2.value = innerDiameter2;
                innerValue2.textContent = innerDiameter2;
            }
            innerDiameterSlider2.max = outerDiameter2 - 50;
            
            draw();
        });

        innerDiameterSlider2.addEventListener('input', (e) => {
            innerDiameter2 = parseInt(e.target.value);
            innerValue2.textContent = innerDiameter2;
            draw();
        });

        resolutionSlider2.addEventListener('input', (e) => {
            resolution2 = parseInt(e.target.value);
            resolutionValue2.textContent = resolution2;
            draw();
        });

        polarLinesSlider2.addEventListener('input', (e) => {
            polarLinesPerSegment2 = parseInt(e.target.value);
            polarLinesValue2.textContent = polarLinesPerSegment2;
            draw();
        });

        curvedLinesSlider.addEventListener('input', (e) => {
            curvedLinesCount = parseInt(e.target.value);
            curvedLinesValue.textContent = curvedLinesCount;
            draw();
        });

        curveSpacingBiasSlider.addEventListener('input', (e) => {
            curveSpacingBias = parseFloat(e.target.value);
            curveSpacingBiasValue.textContent = curveSpacingBias.toFixed(1);
            draw();
        });

        dotSpacingOnCurvesSlider.addEventListener('input', (e) => {
            dotSpacingOnCurves = parseInt(e.target.value);
            dotSpacingOnCurvesValue.textContent = dotSpacingOnCurves;
            draw();
        });

        // Option 3 Event listeners
        outerDiameterSlider3.addEventListener('input', (e) => {
            outerDiameter3 = parseInt(e.target.value);
            outerValue3.textContent = outerDiameter3;
            
            if (innerDiameter3 >= outerDiameter3) {
                innerDiameter3 = outerDiameter3 - 50;
                innerDiameterSlider3.value = innerDiameter3;
                innerValue3.textContent = innerDiameter3;
            }
            innerDiameterSlider3.max = outerDiameter3 - 50;
            
            draw();
        });

        innerDiameterSlider3.addEventListener('input', (e) => {
            innerDiameter3 = parseInt(e.target.value);
            innerValue3.textContent = innerDiameter3;
            draw();
        });

        resolutionSlider3.addEventListener('input', (e) => {
            resolution3 = parseInt(e.target.value);
            resolutionValue3.textContent = resolution3;
            draw();
        });

        polarLinesSlider3.addEventListener('input', (e) => {
            polarLinesPerSegment3 = parseInt(e.target.value);
            polarLinesValue3.textContent = polarLinesPerSegment3;
            draw();
        });

        gridSquareSizeSlider.addEventListener('input', (e) => {
            gridSquareSize = parseInt(e.target.value);
            gridSquareSizeValue.textContent = gridSquareSize;
            draw();
        });

        // Drawing functions
        function drawSemiCircle(centerX, centerY, radius, segments, isFilled, color) {
            ctx.strokeStyle = color;
            ctx.fillStyle = color;
            ctx.lineWidth = 2;

            // Generate points for the semicircle
            const points = [];
            for (let i = 0; i <= segments; i++) {
                const angle = Math.PI * (i / segments); // 0 to PI for semicircle
                const x = centerX + radius * Math.cos(angle);
                const y = centerY - radius * Math.sin(angle);
                points.push({ x, y });
            }

            // Draw the tessellated curve
            ctx.beginPath();
            ctx.moveTo(points[0].x, points[0].y);
            
            for (let i = 1; i < points.length; i++) {
                ctx.lineTo(points[i].x, points[i].y);
            }

            if (isFilled) {
                // Close the path to the starting point
                ctx.lineTo(points[0].x, points[0].y);
                ctx.closePath();
                ctx.fill();
            } else {
                ctx.stroke();
            }

            // Draw vertices to show tessellation
            if (segments < 30) {
                ctx.fillStyle = '#ff4444';
                points.forEach(point => {
                    ctx.beginPath();
                    ctx.arc(point.x, point.y, 4, 0, Math.PI * 2);
                    ctx.fill();
                });
            }
        }

        function drawPolarLines(centerX, centerY, innerRadius, outerRadius, segments, linesPerSegment) {
            if (linesPerSegment === 0) return;

            ctx.strokeStyle = '#e74c3c';
            ctx.lineWidth = 1.5;

            // Calculate total number of evenly spaced lines including segment boundaries
            const totalLines = segments * linesPerSegment + segments + 1;
            const angleStep = Math.PI / (totalLines - 1);

            // Store line positions for dot drawing
            const linePositions = [];

            // Draw all polar lines at evenly spaced angles
            for (let i = 0; i < totalLines; i++) {
                const angle = angleStep * i;
                
                const innerX = centerX + innerRadius * Math.cos(angle);
                const innerY = centerY - innerRadius * Math.sin(angle);
                const outerX = centerX + outerRadius * Math.cos(angle);
                const outerY = centerY - outerRadius * Math.sin(angle);

                ctx.beginPath();
                ctx.moveTo(innerX, innerY);
                ctx.lineTo(outerX, outerY);
                ctx.stroke();

                linePositions.push({ innerX, innerY, outerX, outerY });
            }

            return linePositions;
        }

        function drawDotsOnPolarLines(linePositions, dotsPerLine, bias) {
            if (dotsPerLine === 0 || !linePositions) return;

            ctx.fillStyle = '#2c3e50';

            linePositions.forEach(line => {
                if (dotsPerLine === 1) {
                    // Single dot stays in the middle
                    const t = 0.5;
                    const x = line.innerX + (line.outerX - line.innerX) * t;
                    const y = line.innerY + (line.outerY - line.innerY) * t;
                    ctx.beginPath();
                    ctx.arc(x, y, 3, 0, Math.PI * 2);
                    ctx.fill();
                    return;
                }

                // Fixed start and end positions for dots
                const startT = 0.1;
                const endT = 0.9;
                
                // Exponential spacing in polar system
                // bias = 0 means linear (equal) spacing
                // bias > 0 means exponential growth toward outer (smaller spacing near inner, larger near outer)
                // bias < 0 means exponential growth toward inner (larger spacing near inner, smaller near outer)
                
                const positions = [];
                
                // Use exponential interpolation
                for (let i = 0; i < dotsPerLine; i++) {
                    const linearT = i / (dotsPerLine - 1); // 0 to 1
                    
                    let normalizedT;
                    if (Math.abs(bias) < 0.001) {
                        // Near zero bias, use linear spacing
                        normalizedT = linearT;
                    } else {
                        // Apply exponential curve: e^(bias*x)
                        const expMin = Math.exp(bias * 0);
                        const expMax = Math.exp(bias * 1);
                        const expValue = Math.exp(bias * linearT);
                        
                        // Normalize to 0-1 range
                        normalizedT = (expValue - expMin) / (expMax - expMin);
                    }
                    
                    // Map to actual range
                    const t = startT + normalizedT * (endT - startT);
                    positions.push(t);
                }
                
                // Draw dots at calculated positions
                positions.forEach(t => {
                    const x = line.innerX + (line.outerX - line.innerX) * t;
                    const y = line.innerY + (line.outerY - line.innerY) * t;

                    ctx.beginPath();
                    ctx.arc(x, y, 3, 0, Math.PI * 2);
                    ctx.fill();
                });
            });
        }

        function drawCurvedLines(centerX, centerY, innerRadius, outerRadius, polarLinePositions, curvedLinesCount, bias, dotSpacing) {
            if (curvedLinesCount === 0 || !polarLinePositions || polarLinePositions.length < 2) return;

            ctx.strokeStyle = '#9b59b6';
            ctx.lineWidth = 1.5;

            // Calculate radial positions for curved lines using exponential spacing
            const radialPositions = [];
            for (let i = 0; i < curvedLinesCount; i++) {
                const linearT = (i + 1) / (curvedLinesCount + 1);
                
                let normalizedT;
                if (Math.abs(bias) < 0.001) {
                    normalizedT = linearT;
                } else {
                    const expMin = Math.exp(bias * 0);
                    const expMax = Math.exp(bias * 1);
                    const expValue = Math.exp(bias * linearT);
                    normalizedT = (expValue - expMin) / (expMax - expMin);
                }
                
                const radius = innerRadius + (outerRadius - innerRadius) * normalizedT;
                radialPositions.push(radius);
            }

            // Draw curved lines at each radial position
            radialPositions.forEach(radius => {
                ctx.beginPath();
                
                // Store angles for dot placement
                const angles = [];
                
                // For each polar line, calculate the point at this radius
                polarLinePositions.forEach((line, index) => {
                    // Calculate angle of this polar line
                    const dx = line.outerX - centerX;
                    const dy = centerY - line.outerY;
                    const angle = Math.atan2(dy, dx);
                    angles.push(angle);
                    
                    // Calculate point at this radius and angle
                    const x = centerX + radius * Math.cos(angle);
                    const y = centerY - radius * Math.sin(angle);
                    
                    if (index === 0) {
                        ctx.moveTo(x, y);
                    } else {
                        ctx.lineTo(x, y);
                    }
                });
                
                ctx.stroke();

                // Draw dots on this curved line
                if (dotSpacing > 0 && angles.length > 0) {
                    // Calculate arc length: radius * angle_range
                    const startAngle = angles[0];
                    const endAngle = angles[angles.length - 1];
                    const angleRange = endAngle - startAngle;
                    const arcLength = radius * angleRange;
                    
                    // Calculate number of dots based on arc length and spacing
                    const numDots = Math.floor(arcLength / dotSpacing);
                    
                    if (numDots > 0) {
                        ctx.fillStyle = '#2c3e50';
                        
                        for (let i = 1; i <= numDots; i++) {
                            const t = i / (numDots + 1);
                            const angle = startAngle + angleRange * t;
                            
                            const x = centerX + radius * Math.cos(angle);
                            const y = centerY - radius * Math.sin(angle);
                            
                            ctx.beginPath();
                            ctx.arc(x, y, 3, 0, Math.PI * 2);
                            ctx.fill();
                        }
                    }
                }
            });
        }

        function drawProjectedGrid(centerX, centerY, innerRadius, outerRadius, polarLinePositions, gridSquareSize) {
            if (gridSquareSize === 0) return;

            ctx.strokeStyle = '#e67e22';
            ctx.lineWidth = 1;

            // Calculate the bounding box for the Cartesian grid
            const minX = centerX - outerRadius;
            const maxX = centerX + outerRadius;
            const minY = centerY - outerRadius;
            const maxY = centerY;

            // Helper function to check if a point is within the polar region
            function isInPolarRegion(x, y) {
                const dx = x - centerX;
                const dy = y - centerY;
                const distance = Math.sqrt(dx * dx + dy * dy);
                
                // Check if above centerY (in semicircle region) and within radius bounds
                return y <= centerY && distance >= innerRadius && distance <= outerRadius;
            }

            // Draw horizontal grid lines (constant Y in Cartesian space)
            const numHorizontalLines = Math.ceil((maxY - minY) / gridSquareSize);
            for (let i = 0; i <= numHorizontalLines; i++) {
                const y = minY + i * gridSquareSize;
                
                ctx.beginPath();
                let drawing = false;
                
                // Sample along the horizontal line
                for (let x = minX; x <= maxX; x += 2) {
                    if (isInPolarRegion(x, y)) {
                        if (!drawing) {
                            ctx.moveTo(x, y);
                            drawing = true;
                        } else {
                            ctx.lineTo(x, y);
                        }
                    } else {
                        if (drawing) {
                            ctx.stroke();
                            ctx.beginPath();
                            drawing = false;
                        }
                    }
                }
                if (drawing) {
                    ctx.stroke();
                }
            }

            // Draw vertical grid lines (constant X in Cartesian space)
            const numVerticalLines = Math.ceil((maxX - minX) / gridSquareSize);
            for (let i = 0; i <= numVerticalLines; i++) {
                const x = minX + i * gridSquareSize;
                
                ctx.beginPath();
                let drawing = false;
                
                // Sample along the vertical line
                for (let y = minY; y <= maxY; y += 2) {
                    if (isInPolarRegion(x, y)) {
                        if (!drawing) {
                            ctx.moveTo(x, y);
                            drawing = true;
                        } else {
                            ctx.lineTo(x, y);
                        }
                    } else {
                        if (drawing) {
                            ctx.stroke();
                            ctx.beginPath();
                            drawing = false;
                        }
                    }
                }
                if (drawing) {
                    ctx.stroke();
                }
            }

            // Draw dots at grid intersections
            ctx.fillStyle = '#2c3e50';
            for (let i = 0; i <= numHorizontalLines; i++) {
                const y = minY + i * gridSquareSize;
                for (let j = 0; j <= numVerticalLines; j++) {
                    const x = minX + j * gridSquareSize;
                    
                    if (isInPolarRegion(x, y)) {
                        ctx.beginPath();
                        ctx.arc(x, y, 2.5, 0, Math.PI * 2);
                        ctx.fill();
                    }
                }
            }
        }

        function draw() {
            // Clear canvas
            ctx.fillStyle = '#f5f5f5';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            const centerX = canvas.width / 2;
            const centerY = canvas.height - 100;

            if (currentOption === 1) {
                // Option 1: Dots on polar lines
                const outerRadius = outerDiameter / 2;
                const innerRadius = innerDiameter / 2;

                // Draw floor/base
                ctx.fillStyle = '#333';
                ctx.fillRect(centerX - outerRadius, centerY, outerRadius * 2, 2);

                // Draw outer wall
                drawSemiCircle(centerX, centerY, outerRadius, resolution, false, '#2c3e50');

                // Draw inner wall
                drawSemiCircle(centerX, centerY, innerRadius, resolution, false, '#3498db');

                // Fill the wall area
                ctx.globalAlpha = 0.2;
                drawSemiCircle(centerX, centerY, outerRadius, resolution, true, '#34495e');
                ctx.globalAlpha = 1.0;

                // Draw polar lines and get their positions
                const linePositions = drawPolarLines(centerX, centerY, innerRadius, outerRadius, resolution, polarLinesPerSegment);
                
                // Draw dots on polar lines with spacing bias
                drawDotsOnPolarLines(linePositions, dotsPerLine, spacingBias);

                // Draw connecting lines at the ends
                ctx.strokeStyle = '#2c3e50';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.moveTo(centerX - outerRadius, centerY);
                ctx.lineTo(centerX - innerRadius, centerY);
                ctx.stroke();

                ctx.beginPath();
                ctx.moveTo(centerX + outerRadius, centerY);
                ctx.lineTo(centerX + innerRadius, centerY);
                ctx.stroke();

                // Add grid lines
                ctx.strokeStyle = '#ddd';
                ctx.lineWidth = 1;
                ctx.setLineDash([5, 5]);
                
                // Vertical center line
                ctx.beginPath();
                ctx.moveTo(centerX, 50);
                ctx.lineTo(centerX, centerY);
                ctx.stroke();
                
                ctx.setLineDash([]);

                // Add labels
                ctx.fillStyle = '#333';
                ctx.font = '14px Arial';
                ctx.textAlign = 'center';
                
                ctx.fillText(`Outer: ${outerDiameter}px`, centerX, centerY + 30);
                ctx.fillText(`Inner: ${innerDiameter}px`, centerX, centerY + 50);
                ctx.fillText(`Segments: ${resolution} | Lines/Segment: ${polarLinesPerSegment}`, centerX, centerY + 70);
            } else if (currentOption === 2) {
                // Option 2: Curved lines
                const outerRadius = outerDiameter2 / 2;
                const innerRadius = innerDiameter2 / 2;

                // Draw floor/base
                ctx.fillStyle = '#333';
                ctx.fillRect(centerX - outerRadius, centerY, outerRadius * 2, 2);

                // Draw outer wall
                drawSemiCircle(centerX, centerY, outerRadius, resolution2, false, '#2c3e50');

                // Draw inner wall
                drawSemiCircle(centerX, centerY, innerRadius, resolution2, false, '#3498db');

                // Fill the wall area
                ctx.globalAlpha = 0.2;
                drawSemiCircle(centerX, centerY, outerRadius, resolution2, true, '#34495e');
                ctx.globalAlpha = 1.0;

                // Draw polar lines and get their positions
                const linePositions = drawPolarLines(centerX, centerY, innerRadius, outerRadius, resolution2, polarLinesPerSegment2);
                
                // Draw curved lines connecting polar lines with dots
                drawCurvedLines(centerX, centerY, innerRadius, outerRadius, linePositions, curvedLinesCount, curveSpacingBias, dotSpacingOnCurves);

                // Draw connecting lines at the ends
                ctx.strokeStyle = '#2c3e50';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.moveTo(centerX - outerRadius, centerY);
                ctx.lineTo(centerX - innerRadius, centerY);
                ctx.stroke();

                ctx.beginPath();
                ctx.moveTo(centerX + outerRadius, centerY);
                ctx.lineTo(centerX + innerRadius, centerY);
                ctx.stroke();

                // Add grid lines
                ctx.strokeStyle = '#ddd';
                ctx.lineWidth = 1;
                ctx.setLineDash([5, 5]);
                
                // Vertical center line
                ctx.beginPath();
                ctx.moveTo(centerX, 50);
                ctx.lineTo(centerX, centerY);
                ctx.stroke();
                
                ctx.setLineDash([]);

                // Add labels
                ctx.fillStyle = '#333';
                ctx.font = '14px Arial';
                ctx.textAlign = 'center';
                
                ctx.fillText(`Outer: ${outerDiameter2}px`, centerX, centerY + 30);
                ctx.fillText(`Inner: ${innerDiameter2}px`, centerX, centerY + 50);
                ctx.fillText(`Segments: ${resolution2} | Curved Lines: ${curvedLinesCount}`, centerX, centerY + 70);
            } else if (currentOption === 3) {
                // Option 3: Grid projection
                const outerRadius = outerDiameter3 / 2;
                const innerRadius = innerDiameter3 / 2;

                // Draw floor/base
                ctx.fillStyle = '#333';
                ctx.fillRect(centerX - outerRadius, centerY, outerRadius * 2, 2);

                // Draw outer wall
                drawSemiCircle(centerX, centerY, outerRadius, resolution3, false, '#2c3e50');

                // Draw inner wall
                drawSemiCircle(centerX, centerY, innerRadius, resolution3, false, '#3498db');

                // Fill the wall area
                ctx.globalAlpha = 0.2;
                drawSemiCircle(centerX, centerY, outerRadius, resolution3, true, '#34495e');
                ctx.globalAlpha = 1.0;

                // Draw polar lines and get their positions
                const linePositions = drawPolarLines(centerX, centerY, innerRadius, outerRadius, resolution3, polarLinesPerSegment3);
                
                // Draw projected grid
                drawProjectedGrid(centerX, centerY, innerRadius, outerRadius, linePositions, gridSquareSize);

                // Draw connecting lines at the ends
                ctx.strokeStyle = '#2c3e50';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.moveTo(centerX - outerRadius, centerY);
                ctx.lineTo(centerX - innerRadius, centerY);
                ctx.stroke();

                ctx.beginPath();
                ctx.moveTo(centerX + outerRadius, centerY);
                ctx.lineTo(centerX + innerRadius, centerY);
                ctx.stroke();

                // Add grid lines
                ctx.strokeStyle = '#ddd';
                ctx.lineWidth = 1;
                ctx.setLineDash([5, 5]);
                
                // Vertical center line
                ctx.beginPath();
                ctx.moveTo(centerX, 50);
                ctx.lineTo(centerX, centerY);
                ctx.stroke();
                
                ctx.setLineDash([]);

                // Add labels
                ctx.fillStyle = '#333';
                ctx.font = '14px Arial';
                ctx.textAlign = 'center';
                
                ctx.fillText(`Outer: ${outerDiameter3}px`, centerX, centerY + 30);
                ctx.fillText(`Inner: ${innerDiameter3}px`, centerX, centerY + 50);
                ctx.fillText(`Grid Square Size: ${gridSquareSize}px`, centerX, centerY + 70);
            }
        }

        // Initial draw
        draw();
    </script>
</body>
</html>

